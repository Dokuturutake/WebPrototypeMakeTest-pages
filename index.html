<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ECS MindMap Engine - Shake & Particle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/8.0.0/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #f8fafc; 
            font-family: sans-serif; 
            touch-action: none; 
            -webkit-text-size-adjust: none;
        }
        canvas { display: block; touch-action: none; }
        .ui-layer { pointer-events: none; position: absolute; inset: 0; z-index: 10; }
        .ui-layer * { pointer-events: auto; }
        
        #direct-editor-container {
            position: fixed;
            top: 0; left: 0;
            pointer-events: none;
            z-index: 100;
        }
        .direct-input {
            position: absolute;
            background: white;
            border: 2px solid #3b82f6;
            border-radius: 8px;
            padding: 4px 8px;
            outline: none;
            box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.2);
            pointer-events: auto;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        .direct-title-input { font-size: 18px; font-weight: 900; width: 200px; }
        .direct-content-input { font-size: 13px; font-family: monospace; width: 240px; height: 80px; resize: none; text-align: left; }

        #trash-bin {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #trash-bin.visible { opacity: 1; transform: scale(1); pointer-events: auto; }
        #trash-bin.hidden-trash { opacity: 0; transform: scale(0.8); pointer-events: none; }
        #trash-bin.active { transform: scale(1.2); background-color: #ef4444; color: white; box-shadow: 0 0 30px rgba(239, 68, 68, 0.6); border-color: #ef4444; }

        .modal-overlay { transition: opacity 0.2s ease; }
        .modal-overlay.hidden { display: none; opacity: 0; }

        #search-container { transition: all 0.3s ease; transform: translateY(-20px); opacity: 0; pointer-events: none; }
        #search-container.visible { transform: translateY(0); opacity: 1; pointer-events: auto; }

        button:disabled { opacity: 0.3; cursor: not-allowed; pointer-events: none; }

        .detail-panel {
            position: fixed;
            inset: 0;
            z-index: 200;
            pointer-events: auto;
        }

        .detail-panel.hidden {
            display: none;
        }

        .detail-panel-overlay {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.5);
            backdrop-filter: blur(4px);
            animation: fadeIn 0.3s ease;
        }

        .detail-panel-content {
            position: absolute;
            background: white;
            border-radius: 24px 24px 0 0;
            box-shadow: 0 -10px 50px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            max-height: 70vh;
            animation: slideUp 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* „É¢„Éê„Ç§„É´: ‰∏ã„Åã„Çâ */
        @media (max-width: 768px) {
            .detail-panel-content {
                bottom: 0;
                left: 0;
                right: 0;
            }
        }

        /* „Éá„Çπ„ÇØ„Éà„ÉÉ„Éó: Âè≥„Åã„Çâ */
        @media (min-width: 769px) {
            .detail-panel-content {
                top: 0;
                right: 0;
                bottom: 0;
                width: 400px;
                border-radius: 0;
                max-height: 100vh;
                animation: slideLeft 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }
        }

        .detail-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 24px;
            border-bottom: 1px solid #e2e8f0;
        }

        .detail-panel-header h3 {
            font-size: 20px;
            font-weight: 900;
            color: #1e293b;
            margin: 0;
        }

        .detail-panel-close-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            color: #64748b;
            border-radius: 8px;
            transition: all 0.2s;
            font-size: 24px;
            line-height: 1;
        }

        .detail-panel-close-btn:hover {
            background: #f1f5f9;
            color: #1e293b;
        }

        .detail-panel-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
        }

        .detail-field {
            margin-bottom: 20px;
        }

        .detail-field label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #475569;
            margin-bottom: 8px;
        }

        .detail-input,
        .detail-textarea {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 16px;
            color: #1e293b;
            background: #f8fafc;
            transition: all 0.2s;
            font-family: inherit;
            box-sizing: border-box;
        }

        .detail-input:focus,
        .detail-textarea:focus {
            outline: none;
            border-color: #3b82f6;
            background: white;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .detail-textarea {
            resize: vertical;
            min-height: 120px;
        }

        .detail-markdown {
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            background: #f8fafc;
            min-height: 120px;
            color: #1e293b;
            line-height: 1.6;
        }

        .detail-markdown h1, .detail-markdown h2, .detail-markdown h3 {
            font-weight: 700;
            margin-top: 1em;
            margin-bottom: 0.5em;
            color: #1e293b;
        }

        .detail-markdown h1 { font-size: 1.5em; }
        .detail-markdown h2 { font-size: 1.3em; }
        .detail-markdown h3 { font-size: 1.1em; }

        .detail-markdown p {
            margin-bottom: 0.5em;
        }

        .detail-markdown ul, .detail-markdown ol {
            margin-left: 1.5em;
            margin-bottom: 0.5em;
        }

        .detail-markdown code {
            background: #e2e8f0;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
        }

        .detail-markdown pre {
            background: #e2e8f0;
            padding: 12px;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 0.5em;
        }

        .detail-markdown pre code {
            background: none;
            padding: 0;
        }

        .detail-markdown a {
            color: #3b82f6;
            text-decoration: underline;
        }

        .detail-markdown blockquote {
            border-left: 4px solid #e2e8f0;
            padding-left: 1em;
            margin-left: 0;
            color: #64748b;
        }

        .edit-mode-btn {
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .edit-mode-btn.active {
            background: #3b82f6;
            color: white;
        }

        .edit-mode-btn:not(.active) {
            background: #f1f5f9;
            color: #64748b;
        }

        .edit-mode-btn:not(.active):hover {
            background: #e2e8f0;
            color: #475569;
        }

        .hidden {
            display: none !important;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        @keyframes slideLeft {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }
    </style>
</head>
<body>

    <div id="app">
        <div class="ui-layer h-screen">
            <div class="absolute top-6 left-6 flex flex-col gap-4">
                <div class="flex gap-2">
                    <button id="btn-undo" title="ÂÖÉ„Å´Êàª„Åô" class="p-3 bg-white rounded-2xl shadow-lg border border-slate-100 hover:bg-slate-50 active:scale-95 transition-all w-12 h-12 flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>
                    </button>
                    <button id="btn-redo" title="„ÇÑ„ÇäÁõ¥„Åó" class="p-3 bg-white rounded-2xl shadow-lg border border-slate-100 hover:bg-slate-50 active:scale-95 transition-all w-12 h-12 flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m21 7-6 6h6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7"/></svg>
                    </button>
                    <div class="w-px h-8 bg-slate-200 self-center mx-1"></div>
                    <button id="btn-search-toggle" title="Ê§úÁ¥¢" class="p-3 bg-white rounded-2xl shadow-lg border border-slate-100 hover:bg-slate-50 active:scale-95 transition-all w-12 h-12 flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>
                    </button>
                    <button id="btn-help" title="„Éò„É´„Éó" class="p-3 bg-blue-500 text-white rounded-2xl shadow-lg hover:bg-blue-600 active:scale-95 transition-all w-12 h-12 flex items-center justify-center font-bold text-xl">?</button>
                </div>
                <div id="search-container" class="bg-white p-2 rounded-2xl shadow-xl border border-slate-100 flex items-center gap-2 w-72">
                    <input type="text" id="input-search" placeholder="„Ç≠„Éº„ÉØ„Éº„Éâ„ÅßÊ§úÁ¥¢..." class="flex-1 bg-transparent border-none outline-none px-2 text-sm text-slate-700">
                    <button id="btn-search-clear" class="text-slate-400 hover:text-slate-600 p-1">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                    </button>
                </div>
            </div>

            <div id="guide-overlay" class="hidden modal-overlay absolute inset-0 bg-slate-900/40 backdrop-blur-sm flex items-center justify-center p-6 z-50 pointer-events-auto">
                <div class="bg-white rounded-[32px] shadow-2xl p-8 max-w-sm w-full relative">
                    <button id="btn-guide-close" class="absolute top-4 right-4 p-2 text-slate-400 hover:text-slate-600">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                    </button>
                    <h2 class="text-xl font-black text-slate-800 mb-6 flex items-center gap-2">
                        <span class="bg-blue-500 text-white w-8 h-8 rounded-lg flex items-center justify-center text-sm">?</span>
                        Êìç‰Ωú„Ç¨„Ç§„Éâ
                    </h2>
                    <div class="space-y-4">
                        <div class="flex gap-4">
                            <div class="w-10 h-10 rounded-full bg-slate-100 flex items-center justify-center shrink-0">üëÜ</div>
                            <div>
                                <p class="font-bold text-slate-700 text-sm">ËÉåÊôØ„ÉÄ„Éñ„É´„Çø„ÉÉ„Éó</p>
                                <p class="text-xs text-slate-500">Êñ∞„Åó„ÅÑ„Éé„Éº„Éâ„ÇíÈÖçÁΩÆ„Åó„Åæ„Åô„ÄÇ</p>
                            </div>
                        </div>
                        <div class="flex gap-4">
                            <div class="w-10 h-10 rounded-full bg-slate-100 flex items-center justify-center shrink-0">ü§ù</div>
                            <div>
                                <p class="font-bold text-slate-700 text-sm">„Éé„Éº„Éâ„Çí„Ç∑„Çß„Ç§„ÇØ</p>
                                <p class="text-xs text-slate-500">„Éâ„É©„ÉÉ„Ç∞‰∏≠„Å´ÊøÄ„Åó„ÅèÊåØ„Çã„Å®ÁµêÂêà„ÇíËß£Èô§„Åó„Åæ„Åô„ÄÇ</p>
                            </div>
                        </div>
                        <div class="flex gap-4">
                            <div class="w-10 h-10 rounded-full bg-slate-100 flex items-center justify-center shrink-0">üéØ</div>
                            <div>
                                <p class="font-bold text-slate-700 text-sm">„Éé„Éº„Éâ„Çí„Éâ„É©„ÉÉ„Ç∞</p>
                                <p class="text-xs text-slate-500">ÁßªÂãï„ÄÅÈáç„Å≠„Å¶ÁµêÂêà„ÄÅÂè≥‰∏ã„ÅßÂâäÈô§„ÄÇ</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="absolute bottom-6 left-6 bg-slate-900/80 backdrop-blur px-4 py-2 rounded-full text-[10px] font-mono text-white flex items-center gap-4">
                <span id="stat-fps">FPS: --</span>
                <span id="stat-entities">ENTITIES: 0</span>
                <span id="stat-lod">LOD: DETAIL</span>
            </div>

            <div id="trash-bin" class="hidden-trash fixed bottom-6 right-6 w-24 h-24 bg-white/90 backdrop-blur rounded-[32px] border-2 border-dashed border-slate-300 flex items-center justify-center text-slate-400 shadow-2xl z-40 transition-transform">
                <div class="flex flex-col items-center gap-1">
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>
                    <span class="text-[10px] font-black uppercase tracking-widest text-slate-400">DELETE</span>
                </div>
            </div>

            <div id="detail-panel" class="detail-panel hidden">
                <div class="detail-panel-overlay"></div>
                <div class="detail-panel-content">
                    <div class="detail-panel-header">
                        <h3>„Éé„Éº„ÉâË©≥Á¥∞</h3>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <button id="detail-mode-toggle" class="edit-mode-btn active" title="Á∑®ÈõÜ„É¢„Éº„Éâ„Å®Ë°®Á§∫„É¢„Éº„Éâ„ÇíÂàá„ÇäÊõø„Åà">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/>
                                </svg>
                                <span>Á∑®ÈõÜ</span>
                            </button>
                            <button id="detail-panel-close" class="detail-panel-close-btn">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="detail-panel-body">
                        <div class="detail-field">
                            <label>„Çø„Ç§„Éà„É´</label>
                            <input type="text" id="detail-title" class="detail-input" placeholder="„Çø„Ç§„Éà„É´„ÇíÂÖ•Âäõ...">
                        </div>
                        <div class="detail-field">
                            <label>ÂÜÖÂÆπ</label>
                            <textarea id="detail-content" class="detail-textarea" rows="6" placeholder="Markdown„ÅßË®òËø∞„Åß„Åç„Åæ„Åô...&#10;&#10;‰æã:&#10;# Ë¶ãÂá∫„Åó&#10;**Â§™Â≠ó** *Êñú‰Ωì*&#10;- „É™„Çπ„ÉàÈ†ÖÁõÆ&#10;[„É™„É≥„ÇØ](URL)"></textarea>
                            <div id="detail-content-preview" class="detail-markdown hidden"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="direct-editor-container"></div>
    </div>

    <script>
        document.addEventListener('touchstart', (e) => { if (e.touches.length > 1) e.preventDefault(); }, { passive: false });
        document.addEventListener('wheel', (e) => { if (e.ctrlKey) e.preventDefault(); }, { passive: false });

        const { Application, Container, Graphics, Text, TextStyle } = PIXI;

        const CONFIG = {
            ZOOM: { ICON: 0.2, TITLE: 0.6, MIN: 0.05, MAX: 4.0 },
            NODE: { RADIUS: 120, HIT: 120 }, 
            PHYSICS: { REP: 0.6, FRIC: 0.7, LINK_STRENGTH: 0.02 },
            COLORS: [0x3b82f6, 0x10b981, 0xf59e0b, 0xf43f5e, 0xa855f7, 0x06b6d4, 0x84cc16, 0xec4899],
            SHAKE: { THRESHOLD: 35, COUNT: 8, WINDOW: 300 },
            UI: { FOCUS_DELAY: 100 }
        };

        class World {
            constructor() {
                this.entities = new Set();
                this.systems = [];
                this.components = {
                    position: new Map(),
                    velocity: new Map(),
                    nodeData: new Map(),
                    view: new Map(),
                    theme: new Map(),
                    state: new Map()
                };
            }
            createEntity() {
                const id = Math.random().toString(36).substr(2, 9);
                this.entities.add(id);
                return id;
            }
            removeEntity(id) {
                const view = this.components.view.get(id);
                if (view) view.parent.removeChild(view);
                Object.values(this.components).forEach(map => map.delete(id));
                this.entities.delete(id);
                edges = edges.filter(e => e.source !== id && e.target !== id);
                updateGroupColors(this);
            }
            addSystem(sys) { this.systems.push(sys); }
            update(dt) { this.systems.forEach(s => s(this, dt)); }
        }

        class HistoryManager {
            constructor(world) {
                this.world = world;
                this.undoStack = [];
                this.redoStack = [];
            }
            save() {
                const snapshot = {
                    entities: Array.from(this.world.entities).map(id => ({
                        id,
                        position: { ...this.world.components.position.get(id) },
                        nodeData: { ...this.world.components.nodeData.get(id) },
                        theme: { ...this.world.components.theme.get(id) }
                    })),
                    edges: JSON.parse(JSON.stringify(edges))
                };
                this.undoStack.push(snapshot);
                if (this.undoStack.length > 50) this.undoStack.shift();
                this.redoStack = [];
                this.updateButtons();
            }
            undo() {
                if (this.undoStack.length === 0) return;
                this.redoStack.push(this.getCurrentSnapshot());
                this.applyState(this.undoStack.pop());
            }
            redo() {
                if (this.redoStack.length === 0) return;
                this.undoStack.push(this.getCurrentSnapshot());
                this.applyState(this.redoStack.pop());
            }
            getCurrentSnapshot() {
                return {
                    entities: Array.from(this.world.entities).map(id => ({
                        id,
                        position: { ...this.world.components.position.get(id) },
                        nodeData: { ...this.world.components.nodeData.get(id) },
                        theme: { ...this.world.components.theme.get(id) }
                    })),
                    edges: JSON.parse(JSON.stringify(edges))
                };
            }
            applyState(state) {
                Array.from(this.world.entities).forEach(id => {
                    const view = this.world.components.view.get(id);
                    if (view) view.parent.removeChild(view);
                });
                Object.values(this.world.components).forEach(map => map.clear());
                this.world.entities.clear();
                state.entities.forEach(ent => {
                    const id = ent.id;
                    this.world.entities.add(id);
                    this.world.components.position.set(id, { ...ent.position });
                    this.world.components.velocity.set(id, { x: 0, y: 0 });
                    this.world.components.nodeData.set(id, { ...ent.nodeData });
                    this.world.components.theme.set(id, { ...ent.theme });
                    this.world.components.state.set(id, { needsRedraw: true, isHighlighted: false });
                    const container = new Container();
                    nodeLayer.addChild(container);
                    this.world.components.view.set(id, container);
                });
                edges = state.edges;
                this.updateButtons();
            }
            updateButtons() {
                const u = document.getElementById('btn-undo');
                const r = document.getElementById('btn-redo');
                if(u) u.disabled = this.undoStack.length === 0;
                if(r) r.disabled = this.redoStack.length === 0;
            }
        }

        const world = new World();
        const history = new HistoryManager(world);

        let app, viewport, nodeLayer, edgeLayer, tempLayer, particleLayer;
        let edges = [];
        let particles = [];
        let currentLOD = 'DETAIL';
        let editingSession = null; 
        let searchTerm = "";
        let detailPanelNodeId = null;
        let isDetailEditMode = true; // true = Á∑®ÈõÜ„É¢„Éº„Éâ, false = Ë°®Á§∫„É¢„Éº„Éâ
        
        let interaction = { 
            mode: 'IDLE', 
            activeId: null, 
            pointers: new Map(),
            lastTap: 0,
            pinchDist: 0,
            startScale: 1,
            startMid: { x: 0, y: 0 },
            startView: { x: 0, y: 0 },
            clickPos: { x: 0, y: 0 },
            connectTo: null,
            shakeData: { history: [], lastX: 0, lastY: 0 }
        };

        function updateGroupColors(w) {
            const visited = new Set();
            const adj = new Map();
            w.entities.forEach(id => adj.set(id, []));
            edges.forEach(e => {
                if (adj.has(e.source) && adj.has(e.target)) {
                    adj.get(e.source).push(e.target);
                    adj.get(e.target).push(e.source);
                }
            });
            let colorIdx = 0;
            w.entities.forEach(id => {
                if (!visited.has(id)) {
                    const groupColor = CONFIG.COLORS[colorIdx % CONFIG.COLORS.length];
                    const queue = [id]; visited.add(id);
                    while (queue.length > 0) {
                        const curr = queue.shift();
                        const theme = w.components.theme.get(curr);
                        if (theme && theme.color !== groupColor) {
                            theme.color = groupColor;
                            w.components.state.get(curr).needsRedraw = true;
                        }
                        adj.get(curr).forEach(neighbor => {
                            if (!visited.has(neighbor)) { visited.add(neighbor); queue.push(neighbor); }
                        });
                    }
                    colorIdx++;
                }
            });
        }

        // Particle System
        function createExplosion(x, y, color) {
            for (let i = 0; i < 20; i++) {
                const p = new Graphics();
                p.circle(0, 0, 4 + Math.random() * 6).fill({ color });
                p.x = x;
                p.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 8;
                const particle = {
                    view: p,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.03
                };
                particleLayer.addChild(p);
                particles.push(particle);
            }
        }

        const particleSystem = (dt) => {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.view.x += p.vx;
                p.view.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life -= p.decay;
                p.view.alpha = p.life;
                p.view.scale.set(p.life);
                if (p.life <= 0) {
                    particleLayer.removeChild(p.view);
                    particles.splice(i, 1);
                }
            }
        };

        const physicsSystem = (w, dt) => {
            const ids = Array.from(w.entities);
            const targetDist = (CONFIG.NODE.RADIUS * 2) + 10;
            for (let i = 0; i < ids.length; i++) {
                const id1 = ids[i]; const p1 = w.components.position.get(id1); const v1 = w.components.velocity.get(id1);
                if (!p1 || !v1) continue;
                for (let j = i + 1; j < ids.length; j++) {
                    const id2 = ids[j]; const p2 = w.components.position.get(id2); const v2 = w.components.velocity.get(id2);
                    if (!p2 || !v2) continue;
                    const dx = p2.x - p1.x, dy = p2.y - p1.y, d2 = dx*dx + dy*dy;
                    if (d2 < targetDist * targetDist) {
                        const dist = Math.sqrt(d2) || 1, force = (targetDist - dist) * CONFIG.PHYSICS.REP, nx = dx / dist, ny = dy / dist;
                        if (id1 !== interaction.activeId) { v1.x -= nx * force; v1.y -= ny * force; }
                        if (id2 !== interaction.activeId) { v2.x += nx * force; v2.y += ny * force; }
                    }
                }
            }
            edges.forEach(e => {
                const p1 = w.components.position.get(e.source), p2 = w.components.position.get(e.target), v1 = w.components.velocity.get(e.source), v2 = w.components.velocity.get(e.target);
                if (!p1 || !p2 || !v1 || !v2) return;
                const dx = p2.x - p1.x, dy = p2.y - p1.y, dist = Math.sqrt(dx*dx + dy*dy) || 1, idealDist = 400, force = (dist - idealDist) * CONFIG.PHYSICS.LINK_STRENGTH, nx = dx / dist, ny = dy / dist;
                if (e.source !== interaction.activeId) { v1.x += nx * force; v1.y += ny * force; }
                if (e.target !== interaction.activeId) { v2.x -= nx * force; v2.y -= ny * force; }
            });
            ids.forEach(id => {
                if (id === interaction.activeId) return;
                const p = w.components.position.get(id), v = w.components.velocity.get(id);
                v.x *= CONFIG.PHYSICS.FRIC; v.y *= CONFIG.PHYSICS.FRIC; p.x += v.x; p.y += v.y;
            });
        };

        const renderSystem = (w) => {
            w.entities.forEach(id => {
                const pos = w.components.position.get(id), view = w.components.view.get(id), state = w.components.state.get(id);
                if (!pos || !view) return;
                view.position.set(pos.x, pos.y);
                if (state.needsRedraw) { drawNodeGraphics(id); state.needsRedraw = false; }
                view.alpha = searchTerm.length > 0 ? (state.isHighlighted ? 1.0 : 0.2) : 1.0;
            });
            edgeLayer.clear();
            edges.forEach(e => {
                const p1 = w.components.position.get(e.source), p2 = w.components.position.get(e.target), theme = w.components.theme.get(e.source);
                if (p1 && p2 && theme) {
                    const alpha = (searchTerm.length > 0) ? 0.1 : 0.4;
                    edgeLayer.moveTo(p1.x, p1.y).lineTo(p2.x, p2.y).stroke({ width: 4, color: theme.color, alpha: alpha });
                }
            });
        };

        function drawNodeGraphics(id) {
            const view = world.components.view.get(id), data = world.components.nodeData.get(id), theme = world.components.theme.get(id);
            if (!view) return;
            view.removeChildren();
            const body = new Graphics().circle(0, 0, CONFIG.NODE.RADIUS).fill({ color: 0xffffff }).stroke({ width: 6, color: theme.color });
            view.addChild(body);
            
            if (currentLOD === 'DETAIL') {
                const titleStyle = new TextStyle({ fontSize: 28, fontWeight: '900', fill: theme.color, align: 'center', wordWrap: true, wordWrapWidth: 180 });
                const titleText = new Text({ text: data.title, style: titleStyle });
                titleText.anchor.set(0.5, 0.5);
                view.addChild(titleText);
                if (data.content) {
                    const contentStyle = new TextStyle({ fontSize: 14, fill: 0x64748b, align: 'center', wordWrap: true, wordWrapWidth: 160 });
                    const contentText = new Text({ text: data.content, style: contentStyle });
                    contentText.anchor.set(0.5, 0); contentText.y = 35; view.addChild(contentText); titleText.y = -20;
                }
            } else if (currentLOD === 'TITLE') {
                const t = new Text({ text: data.title.substring(0, 1).toUpperCase(), style: new TextStyle({ fontSize: 40, fontWeight: '900', fill: theme.color }) });
                t.anchor.set(0.5); view.addChild(t);
            } else if (currentLOD === 'ICON') {
                // LOD: ICON„ÅÆ„Å®„Åç„Å´‰∏≠Â§Æ„Å´ÁÇπ„ÇíËøΩÂä†
                const dot = new Graphics().circle(0, 0, 12).fill({ color: theme.color });
                view.addChild(dot);
            }
        }

        async function init() {
            app = new Application();
            await app.init({ resizeTo: window, antialias: true, backgroundColor: 0xf8fafc, resolution: window.devicePixelRatio || 1, autoDensity: true });
            document.body.appendChild(app.canvas);
            viewport = new Container();
            edgeLayer = new Graphics();
            nodeLayer = new Container();
            particleLayer = new Container();
            tempLayer = new Graphics();
            viewport.addChild(edgeLayer, nodeLayer, tempLayer, particleLayer);
            app.stage.addChild(viewport);
            viewport.position.set(app.screen.width / 2, app.screen.height / 2);

            createNode(0, 0, "PROJECT", "Double tap background to add nodes.");
            updateGroupColors(world);

            app.canvas.addEventListener('pointerdown', onPointerDown);
            app.canvas.addEventListener('pointermove', onPointerMove);
            app.canvas.addEventListener('pointerup', onPointerUp);
            app.canvas.addEventListener('wheel', onWheel, { passive: false });

            document.getElementById('btn-help').onclick = () => document.getElementById('guide-overlay').classList.remove('hidden');
            document.getElementById('btn-guide-close').onclick = () => document.getElementById('guide-overlay').classList.add('hidden');
            document.getElementById('btn-undo').onclick = () => history.undo();
            document.getElementById('btn-redo').onclick = () => history.redo();
            document.getElementById('btn-search-toggle').onclick = () => {
                const c = document.getElementById('search-container');
                c.classList.toggle('visible');
                if (c.classList.contains('visible')) document.getElementById('input-search').focus();
            };
            document.getElementById('input-search').oninput = (e) => {
                searchTerm = e.target.value.toLowerCase();
                world.entities.forEach(id => {
                    const data = world.components.nodeData.get(id);
                    world.components.state.get(id).isHighlighted = searchTerm.length > 0 && 
                        (data.title.toLowerCase().includes(searchTerm) || data.content.toLowerCase().includes(searchTerm));
                });
            };
            document.getElementById('btn-search-clear').onclick = () => {
                document.getElementById('input-search').value = ""; searchTerm = "";
                world.entities.forEach(id => world.components.state.get(id).isHighlighted = false);
            };

            document.getElementById('detail-panel-close').onclick = () => closeDetailPanel(true);
            document.getElementById('detail-panel').querySelector('.detail-panel-overlay').onclick = () => closeDetailPanel(true);

            document.getElementById('detail-mode-toggle').onclick = () => {
                isDetailEditMode = !isDetailEditMode;
                updateDetailPanelMode();
            };

            // ESC„Ç≠„Éº„ÅßÈñâ„Åò„Çã
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && detailPanelNodeId) {
                    closeDetailPanel(true);
                }
            });

            app.ticker.add((ticker) => {
                world.update(ticker.deltaTime);
                particleSystem(ticker.deltaTime);
                renderSystem(world);
                const lod = viewport.scale.x < CONFIG.ZOOM.ICON ? 'ICON' : (viewport.scale.x < CONFIG.ZOOM.TITLE ? 'TITLE' : 'DETAIL');
                if (lod !== currentLOD) {
                    currentLOD = lod;
                    world.entities.forEach(id => world.components.state.get(id).needsRedraw = true);
                    document.getElementById('stat-lod').innerText = `LOD: ${lod}`;
                }
                document.getElementById('stat-fps').innerText = `FPS: ${Math.round(ticker.FPS)}`;
                document.getElementById('stat-entities').innerText = `ENTITIES: ${world.entities.size}`;
            });
            world.addSystem(physicsSystem);
        }

        function createNode(x, y, title = "New Node", content = "") {
            const id = world.createEntity();
            world.components.position.set(id, { x, y });
            world.components.velocity.set(id, { x: 0, y: 0 });
            world.components.nodeData.set(id, { title, content });
            world.components.theme.set(id, { color: CONFIG.COLORS[0] });
            world.components.state.set(id, { needsRedraw: true, isHighlighted: false });
            const container = new Container();
            nodeLayer.addChild(container);
            world.components.view.set(id, container);
            createExplosion(x, y, CONFIG.COLORS[0]);
            return id;
        }

        function onPointerDown(e) {
            if (editingSession) return;
            interaction.pointers.set(e.pointerId, e);
            if (interaction.pointers.size === 1) {
                const pos = { x: (e.clientX - viewport.x) / viewport.scale.x, y: (e.clientY - viewport.y) / viewport.scale.y };
                const hit = Array.from(world.entities).reverse().find(id => Math.hypot(world.components.position.get(id).x - pos.x, world.components.position.get(id).y - pos.y) < CONFIG.NODE.HIT);
                if (hit) {
                    interaction.mode = 'DRAG'; interaction.activeId = hit; interaction.clickPos = { x: e.clientX, y: e.clientY };
                    interaction.shakeData = { history: [], lastX: e.clientX, lastY: e.clientY };
                    document.getElementById('trash-bin').classList.replace('hidden-trash', 'visible');
                } else {
                    interaction.mode = 'PAN'; interaction.startView = { x: viewport.x, y: viewport.y }; interaction.clickPos = { x: e.clientX, y: e.clientY };
                    const now = Date.now();
                    if (now - interaction.lastTap < 300) { history.save(); createNode(pos.x, pos.y); updateGroupColors(world); }
                    interaction.lastTap = now;
                }
            } else if (interaction.pointers.size === 2) {
                interaction.mode = 'PINCH';
                const pts = Array.from(interaction.pointers.values());
                interaction.pinchDist = Math.hypot(pts[0].clientX - pts[1].clientX, pts[0].clientY - pts[1].clientY);
                interaction.startScale = viewport.scale.x;
                interaction.startMid = { x: (pts[0].clientX + pts[1].clientX)/2, y: (pts[0].clientY + pts[1].clientY)/2 };
                interaction.startView = { x: viewport.x, y: viewport.y };
            }
        }

        function onPointerMove(e) {
            if (editingSession) return;
            interaction.pointers.set(e.pointerId, e);
            if (interaction.mode === 'DRAG' && interaction.activeId) {
                const pos = { x: (e.clientX - viewport.x) / viewport.scale.x, y: (e.clientY - viewport.y) / viewport.scale.y };
                world.components.position.set(interaction.activeId, pos);
                
                // Shake detection logic
                const dx = e.clientX - interaction.shakeData.lastX;
                const dy = e.clientY - interaction.shakeData.lastY;
                const speed = Math.hypot(dx, dy);
                const now = Date.now();
                interaction.shakeData.history.push({ speed, time: now });
                interaction.shakeData.history = interaction.shakeData.history.filter(h => now - h.time < CONFIG.SHAKE.WINDOW);
                interaction.shakeData.lastX = e.clientX;
                interaction.shakeData.lastY = e.clientY;

                const shakeCount = interaction.shakeData.history.filter(h => h.speed > CONFIG.SHAKE.THRESHOLD).length;
                if (shakeCount > CONFIG.SHAKE.COUNT) {
                    const originalEdgesCount = edges.length;
                    edges = edges.filter(ed => ed.source !== interaction.activeId && ed.target !== interaction.activeId);
                    if (edges.length !== originalEdgesCount) {
                        history.save();
                        updateGroupColors(world);
                        createExplosion(pos.x, pos.y, 0xef4444);
                        interaction.shakeData.history = []; // reset
                    }
                }

                const trash = document.getElementById('trash-bin');
                const rect = trash.getBoundingClientRect();
                const isOver = e.clientX > rect.left && e.clientX < rect.right && e.clientY > rect.top && e.clientY < rect.bottom;
                trash.classList.toggle('active', isOver);
                if (!isOver) {
                    interaction.connectTo = Array.from(world.entities).find(id => id !== interaction.activeId && Math.hypot(world.components.position.get(id).x - pos.x, world.components.position.get(id).y - pos.y) < 300);
                    tempLayer.clear();
                    if (interaction.connectTo) {
                        const p1 = world.components.position.get(interaction.activeId), p2 = world.components.position.get(interaction.connectTo);
                        tempLayer.moveTo(p1.x, p1.y).lineTo(p2.x, p2.y).stroke({ width: 4, color: 0x3b82f6, alpha: 0.5 });
                    }
                }
            } else if (interaction.mode === 'PAN') {
                viewport.x = interaction.startView.x + (e.clientX - interaction.clickPos.x);
                viewport.y = interaction.startView.y + (e.clientY - interaction.clickPos.y);
            } else if (interaction.mode === 'PINCH') {
                const pts = Array.from(interaction.pointers.values());
                const dist = Math.hypot(pts[0].clientX - pts[1].clientX, pts[0].clientY - pts[1].clientY);
                const mid = { x: (pts[0].clientX + pts[1].clientX)/2, y: (pts[0].clientY + pts[1].clientY)/2 };
                const ratio = dist / interaction.pinchDist;
                const newScale = Math.min(Math.max(interaction.startScale * ratio, CONFIG.ZOOM.MIN), CONFIG.ZOOM.MAX);
                const worldMid = { x: (mid.x - interaction.startView.x) / interaction.startScale, y: (mid.y - interaction.startView.y) / interaction.startScale };
                viewport.scale.set(newScale); viewport.x = mid.x - worldMid.x * newScale; viewport.y = mid.y - worldMid.y * newScale;
            }
        }

        function onPointerUp(e) {
            if (interaction.mode === 'DRAG' && interaction.activeId) {
                const trash = document.getElementById('trash-bin');
                if (trash.classList.contains('active')) { history.save(); world.removeEntity(interaction.activeId); }
                else if (interaction.connectTo) {
                    if (!edges.some(edge => (edge.source === interaction.activeId && edge.target === interaction.connectTo) || (edge.source === interaction.connectTo && edge.target === interaction.activeId))) {
                        history.save(); edges.push({ source: interaction.activeId, target: interaction.connectTo }); updateGroupColors(world);
                    }
                } else if (Math.hypot(e.clientX - interaction.clickPos.x, e.clientY - interaction.clickPos.y) < 5) {
                    startEditing(interaction.activeId, e);
                }
            }
            interaction.pointers.delete(e.pointerId);
            if (interaction.pointers.size === 0) {
                interaction.mode = 'IDLE'; interaction.activeId = null; interaction.connectTo = null; tempLayer.clear();
                document.getElementById('trash-bin').classList.replace('visible', 'hidden-trash');
            }
        }

        function onWheel(e) {
            e.preventDefault();
            const worldPos = { x: (e.clientX - viewport.x) / viewport.scale.x, y: (e.clientY - viewport.y) / viewport.scale.y };
            const newScale = Math.min(Math.max(viewport.scale.x * Math.pow(1.1, -e.deltaY / 100), CONFIG.ZOOM.MIN), CONFIG.ZOOM.MAX);
            viewport.scale.set(newScale); viewport.x = e.clientX - worldPos.x * newScale; viewport.y = e.clientY - worldPos.y * newScale;
        }

        function startEditing(id, e) {
            openDetailPanel(id);
        }

        function openDetailPanel(id) {
            if (currentLOD !== 'DETAIL') return;
            
            const data = world.components.nodeData.get(id);
            const theme = world.components.theme.get(id);
            
            detailPanelNodeId = id;
            isDetailEditMode = true; // „Éá„Éï„Ç©„É´„Éà„ÅØÁ∑®ÈõÜ„É¢„Éº„Éâ
            
            const panel = document.getElementById('detail-panel');
            const titleInput = document.getElementById('detail-title');
            const contentInput = document.getElementById('detail-content');
            
            titleInput.value = data.title;
            contentInput.value = data.content;
            
            // „ÉÜ„Éº„Éû„Ç´„É©„Éº„ÇíÈÅ©Áî®
            const colorHex = `#${theme.color.toString(16).padStart(6, '0')}`;
            titleInput.style.borderColor = colorHex;
            titleInput.style.color = colorHex;
            
            panel.classList.remove('hidden');
            updateDetailPanelMode();
            
            // „Éï„Ç©„Éº„Ç´„Çπ
            setTimeout(() => titleInput.focus(), CONFIG.UI.FOCUS_DELAY);
        }

        function updateDetailPanelMode() {
            const modeToggleBtn = document.getElementById('detail-mode-toggle');
            const contentInput = document.getElementById('detail-content');
            const contentPreview = document.getElementById('detail-content-preview');
            const titleInput = document.getElementById('detail-title');
            
            if (isDetailEditMode) {
                // Á∑®ÈõÜ„É¢„Éº„Éâ
                modeToggleBtn.classList.add('active');
                modeToggleBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/>
                    </svg>
                    <span>Á∑®ÈõÜ</span>
                `;
                contentInput.classList.remove('hidden');
                contentPreview.classList.add('hidden');
                titleInput.disabled = false;
            } else {
                // Ë°®Á§∫„É¢„Éº„Éâ
                modeToggleBtn.classList.remove('active');
                modeToggleBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                        <circle cx="12" cy="12" r="3"/>
                    </svg>
                    <span>Ë°®Á§∫</span>
                `;
                contentInput.classList.add('hidden');
                contentPreview.classList.remove('hidden');
                titleInput.disabled = true;
                
                // Markdown„Çí„É¨„É≥„ÉÄ„É™„É≥„Ç∞ (marked v4+„ÅÆAPI„Çí‰ΩøÁî®)
                const markdownContent = contentInput.value || 'ÂÜÖÂÆπ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì';
                try {
                    // marked.parse„Åß„Çµ„Éã„Çø„Ç§„Ç∫„ÇíÊúâÂäπÂåñ
                    contentPreview.innerHTML = marked.parse(markdownContent, { 
                        breaks: true,
                        gfm: true
                    });
                } catch (e) {
                    contentPreview.textContent = 'Markdown„ÅÆ„É¨„É≥„ÉÄ„É™„É≥„Ç∞„Å´Â§±Êïó„Åó„Åæ„Åó„Åü';
                    console.error('Markdown rendering error:', e);
                }
            }
        }

        function closeDetailPanel(save = true) {
            if (!detailPanelNodeId) return;
            
            const panel = document.getElementById('detail-panel');
            const titleInput = document.getElementById('detail-title');
            const contentInput = document.getElementById('detail-content');
            
            if (save && isDetailEditMode) {
                const data = world.components.nodeData.get(detailPanelNodeId);
                const newTitle = titleInput.value.trim() || "Untitled";
                const newContent = contentInput.value.trim();
                
                if (data.title !== newTitle || data.content !== newContent) {
                    history.save();
                    data.title = newTitle;
                    data.content = newContent;
                    world.components.state.get(detailPanelNodeId).needsRedraw = true;
                }
            }
            
            panel.classList.add('hidden');
            detailPanelNodeId = null;
            isDetailEditMode = true; // „É™„Çª„ÉÉ„Éà
        }

        window.onload = init;
    </script>
</body>
</html>